<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlashArb AI - Sistema Aut√¥nomo com Intelig√™ncia Artificial</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e22ce 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00f5ff, #7e22ce, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(45deg); }
        }

        .subtitle {
            color: #a0a0ff;
            font-size: 1.2em;
        }

        .ai-badge {
            display: inline-block;
            background: linear-gradient(135deg, #00f5ff, #7e22ce);
            padding: 8px 20px;
            border-radius: 20px;
            margin-left: 10px;
            font-size: 0.9em;
            animation: pulse 2s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .card h2 {
            color: #00f5ff;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .btn {
            background: linear-gradient(135deg, #00f5ff 0%, #7e22ce 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            transition: all 0.3s;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 245, 255, 0.5);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-success {
            background: linear-gradient(135deg, #00ff88 0%, #00aa55 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff0055 0%, #aa0033 100%);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #a0a0ff;
            font-weight: 600;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transition: all 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #00f5ff;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(126, 34, 206, 0.2) 100%);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
            color: #00f5ff;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            color: #a0a0ff;
        }

        .log {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            border: 1px solid rgba(0, 245, 255, 0.3);
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .log-entry.success {
            border-left-color: #00ff00;
            color: #00ff00;
        }

        .log-entry.error {
            border-left-color: #ff0000;
            color: #ff6b6b;
        }

        .log-entry.info {
            border-left-color: #00bfff;
            color: #00bfff;
        }

        .log-entry.warning {
            border-left-color: #ffa500;
            color: #ffa500;
        }

        .log-entry.ai {
            border-left-color: #ff00ff;
            color: #ff00ff;
        }

        .status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin-left: 10px;
        }

        .status.connected {
            background: #00ff00;
            color: #000;
        }

        .status.disconnected {
            background: #ff0000;
            color: #fff;
        }

        .status.scanning {
            background: #ffa500;
            color: #000;
            animation: pulse 1.5s infinite;
        }

        .status.learning {
            background: linear-gradient(90deg, #00f5ff, #ff00ff);
            color: #fff;
            animation: gradient 2s ease infinite;
        }

        .opportunities {
            max-height: 400px;
            overflow-y: auto;
        }

        .opportunity {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #00ff00;
            transition: all 0.3s;
        }

        .opportunity:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .opportunity-profit {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff00;
        }

        .opportunity-route {
            color: #a0a0ff;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .opportunity-ai {
            color: #ff00ff;
            font-size: 0.85em;
            margin-top: 5px;
            font-style: italic;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00f5ff 0%, #7e22ce 50%, #ff00ff 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .ai-insights {
            background: rgba(126, 34, 206, 0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            margin-top: 15px;
        }

        .ai-insights h3 {
            color: #ff00ff;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .ai-insight-item {
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            font-size: 0.9em;
        }

        .neural-network {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-top: 15px;
        }

        .neuron {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00f5ff, #ff00ff);
            animation: neuronPulse 2s ease infinite;
            position: relative;
        }

        @keyframes neuronPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .learning-graph {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin-top: 15px;
        }

        .graph-line {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: #00f5ff;
            transform-origin: left;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ FlashArb AI <span class="ai-badge">AUTONOMOUS</span></h1>
            <p class="subtitle">Sistema de Arbitragem com Intelig√™ncia Artificial - Aprende, Adapta e Otimiza Automaticamente</p>
        </div>

        <div class="grid">
            <!-- Conex√£o -->
            <div class="card">
                <h2>üîó Conex√£o</h2>
                <div class="input-group">
                    <label>Seu Endere√ßo:</label>
                    <input type="text" id="walletAddress" value="0xe569e1019db12ed084be9655667f3beb15a9b1cc" readonly>
                </div>
                <div class="input-group">
                    <label>Status:</label>
                    <span id="connectionStatus" class="status disconnected">Desconectado</span>
                </div>
                <button id="connectBtn" class="btn">Conectar Carteira</button>
            </div>

            <!-- IA - Configura√ß√£o -->
            <div class="card">
                <h2>üß† IA - Configura√ß√£o</h2>
                <div class="input-group">
                    <label>Modo de Aprendizado:</label>
                    <select id="aiMode">
                        <option value="conservative">Conservador (Seguro)</option>
                        <option value="balanced" selected>Balanceado (Recomendado)</option>
                        <option value="aggressive">Agressivo (M√°ximo Lucro)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Confian√ßa M√≠nima IA:</label>
                    <input type="number" id="aiConfidence" value="70" min="50" max="95" step="5">
                </div>
                <div class="input-group">
                    <label>Auto-Ajuste:</label>
                    <select id="autoAdjust">
                        <option value="enabled" selected>‚úÖ Ativado</option>
                        <option value="disabled">‚ùå Desativado</option>
                    </select>
                </div>
                <div class="neural-network">
                    <div class="neuron" style="animation-delay: 0s;"></div>
                    <div class="neuron" style="animation-delay: 0.3s;"></div>
                    <div class="neuron" style="animation-delay: 0.6s;"></div>
                    <div class="neuron" style="animation-delay: 0.9s;"></div>
                </div>
            </div>

            <!-- Configura√ß√µes Manuais -->
            <div class="card">
                <h2>‚öôÔ∏è Configura√ß√µes</h2>
                <div class="input-group">
                    <label>Valor por Trade (ETH):</label>
                    <input type="number" id="tradeAmount" value="0.005" step="0.001" min="0.001">
                </div>
                <div class="input-group">
                    <label>Lucro M√≠nimo (%):</label>
                    <input type="number" id="minProfit" value="0.3" step="0.1" min="0.1">
                </div>
                <div class="input-group">
                    <label>Workers Paralelos:</label>
                    <select id="workerCount">
                        <option value="8">8 workers</option>
                        <option value="16" selected>16 workers (IA otimizado)</option>
                        <option value="32">32 workers (m√°ximo)</option>
                    </select>
                </div>
            </div>

            <!-- Controle -->
            <div class="card">
                <h2>üéÆ Controle</h2>
                <button id="startBtn" class="btn btn-success" disabled>‚ñ∂Ô∏è Iniciar IA Aut√¥noma</button>
                <button id="stopBtn" class="btn btn-danger" disabled>‚èπÔ∏è Parar</button>
                <button id="trainBtn" class="btn">üéì Treinar IA</button>
                <div class="progress-bar" style="margin-top: 20px;">
                    <div id="scanProgress" class="progress-fill" style="width: 0%">0%</div>
                </div>
            </div>
        </div>

        <!-- Estat√≠sticas -->
        <div class="card">
            <h2>üìä Estat√≠sticas em Tempo Real</h2>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="totalScans">0</div>
                    <div class="stat-label">Total Scans</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="routesScanned">0</div>
                    <div class="stat-label">Rotas Testadas</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="opportunitiesFound">0</div>
                    <div class="stat-label">Oportunidades</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="successfulTrades">0</div>
                    <div class="stat-label">Trades OK</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalProfit">0.000</div>
                    <div class="stat-label">Lucro Total (ETH)</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="aiAccuracy">0%</div>
                    <div class="stat-label">Precis√£o IA</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="learningRate">0</div>
                    <div class="stat-label">Taxa Aprendizado</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="scanSpeed">0</div>
                    <div class="stat-label">Rotas/segundo</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <!-- IA Insights -->
            <div class="card">
                <h2>üîÆ IA - Insights e Previs√µes</h2>
                <div id="aiInsights" class="ai-insights">
                    <h3>üí° An√°lise Inteligente</h3>
                    <div id="insightsList">
                        <div class="ai-insight-item">‚è≥ Aguardando dados para an√°lise...</div>
                    </div>
                </div>
                <div class="learning-graph" id="learningGraph">
                    <canvas id="graphCanvas" width="100%" height="150"></canvas>
                </div>
            </div>

            <!-- Oportunidades -->
            <div class="card">
                <h2>üí∞ Oportunidades (Filtradas por IA)</h2>
                <div id="opportunitiesList" class="opportunities">
                    <p style="color: #a0a0ff; text-align: center; padding: 20px;">
                        Aguardando scanning...
                    </p>
                </div>
            </div>

            <!-- Log -->
            <div class="card">
                <h2>üìù Log de Atividades</h2>
                <div id="logContainer" class="log"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script>
        // ========== CONFIGURA√á√ÉO ==========
        const CONFIG = {
            RPC_URL: 'https://eth.llamarpc.com',
            CHAIN_ID: 1,
            CONTRACT_ADDRESS: '0xe569e1019db12ed084be9655667f3beb15a9b1cc',
            
            DEXS: [
                { name: 'Uniswap V2', router: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D', fee: 0.003 },
                { name: 'Uniswap V3', router: '0xE592427A0AEce92De3Edee1F18E0157C05861564', fee: 0.0025 },
                { name: 'SushiSwap', router: '0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F', fee: 0.003 },
                { name: 'Balancer', router: '0xBA12222222228d8Ba445958a75a0704d566BF2C8', fee: 0.002 },
                { name: 'Curve', router: '0x8e764bE4288B842791989DB5b8ec067279829809', fee: 0.0004 }
            ],

            TOKENS: [
                { symbol: 'WETH', address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', volatility: 0.05 },
                { symbol: 'USDC', address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', volatility: 0.001 },
                { symbol: 'USDT', address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', volatility: 0.001 },
                { symbol: 'DAI', address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', volatility: 0.002 },
                { symbol: 'WBTC', address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', volatility: 0.06 }
            ]
        };

        // ========== ESTADO GLOBAL ==========
        let state = {
            provider: null,
            signer: null,
            wallet: null,
            isScanning: false,
            ai: null,
            stats: {
                totalScans: 0,
                routesScanned: 0,
                opportunitiesFound: 0,
                successfulTrades: 0,
                totalProfit: 0,
                aiPredictions: 0,
                aiCorrect: 0
            },
            learningData: [],
            bestRoutes: [],
            performanceHistory: []
        };

        // ========== CLASSE IA ==========
        class ArbitrageAI {
            constructor() {
                this.model = null;
                this.trainingData = [];
                this.predictions = [];
                this.accuracy = 0;
                this.learningRate = 0;
            }

            async initialize() {
                log('üß† Inicializando rede neural...', 'ai');
                
                // Criar modelo neural simples
                this.model = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [10], units: 64, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'sigmoid' })
                    ]
                });

                this.model.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });

                log('‚úÖ Rede neural criada com sucesso!', 'success');
            }

            extractFeatures(opportunity) {
                // Extrair caracter√≠sticas relevantes
                return [
                    opportunity.profitPercent / 100,
                    opportunity.route.swaps.length / 5,
                    opportunity.gasEstimate / 500000,
                    opportunity.dexDiversity || 0,
                    opportunity.tokenVolatility || 0,
                    opportunity.liquidityScore || 0,
                    opportunity.competitionLevel || 0,
                    opportunity.timeOfDay || 0,
                    opportunity.gasPrice / 100,
                    opportunity.slippageRisk || 0
                ];
            }

            async predict(opportunity) {
                if (!this.model) return { success: 0.5, confidence: 0 };

                const features = this.extractFeatures(opportunity);
                const tensor = tf.tensor2d([features]);
                const prediction = await this.model.predict(tensor).data();
                tensor.dispose();

                const confidence = Math.abs(prediction[0] - 0.5) * 200;
                
                state.stats.aiPredictions++;
                
                return {
                    success: prediction[0],
                    confidence: confidence,
                    recommended: prediction[0] > 0.5 && confidence > parseFloat(document.getElementById('aiConfidence').value)
                };
            }

            async train(data) {
                if (data.length < 10) {
                    log('üìä Coletando mais dados para treinamento...', 'info');
                    return;
                }

                log('üéì Treinando rede neural...', 'ai');

                const features = data.map(d => this.extractFeatures(d.opportunity));
                const labels = data.map(d => d.success ? 1 : 0);

                const xs = tf.tensor2d(features);
                const ys = tf.tensor2d(labels, [labels.length, 1]);

                const history = await this.model.fit(xs, ys, {
                    epochs: 50,
                    batchSize: 32,
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if (epoch % 10 === 0) {
                                this.accuracy = (logs.acc * 100).toFixed(1);
                                this.learningRate = logs.loss.toFixed(4);
                                document.getElementById('aiAccuracy').textContent = this.accuracy + '%';
                                document.getElementById('learningRate').textContent = this.learningRate;
                            }
                        }
                    }
                });

                xs.dispose();
                ys.dispose();

                log(`‚úÖ Treinamento completo! Acur√°cia: ${this.accuracy}%`, 'success');
            }

            recordResult(opportunity, success) {
                this.trainingData.push({
                    opportunity: opportunity,
                    success: success,
                    timestamp: Date.now()
                });

                if (success) state.stats.aiCorrect++;

                // Auto-treinar a cada 20 resultados
                if (this.trainingData.length % 20 === 0) {
                    this.train(this.trainingData.slice(-100));
                }
            }

            analyzeMarketConditions() {
                const insights = [];
                
                // An√°lise de performance
                if (state.stats.successfulTrades > 0) {
                    const successRate = (state.stats.successfulTrades / state.stats.opportunitiesFound * 100).toFixed(1);
                    insights.push(`üìà Taxa de sucesso: ${successRate}% (${state.stats.successfulTrades}/${state.stats.opportunitiesFound})`);
                }

                // An√°lise de lucro m√©dio
                if (state.stats.totalProfit > 0 && state.stats.successfulTrades > 0) {
                    const avgProfit = (state.stats.totalProfit / state.stats.successfulTrades).toFixed(6);
                    insights.push(`üí∞ Lucro m√©dio por trade: ${avgProfit} ETH`);
                }

                // An√°lise de rotas
                if (state.bestRoutes.length > 0) {
                    const bestRoute = state.bestRoutes[0];
                    insights.push(`‚≠ê Melhor rota: ${bestRoute.description} (+${bestRoute.profit.toFixed(4)} ETH)`);
                }

                // Recomenda√ß√µes
                const mode = document.getElementById('aiMode').value;
                if (mode === 'aggressive' && state.stats.successfulTrades < 3) {
                    insights.push(`‚ö†Ô∏è Modo agressivo com poucos trades bem-sucedidos. Considere modo balanceado.`);
                }

                // An√°lise de hor√°rio
                const hour = new Date().getHours();
                if (hour >= 2 && hour <= 6) {
                    insights.push(`üåô Hor√°rio de baixa atividade (02:00-06:00 UTC). Menos competi√ß√£o esperada.`);
                } else if (hour >= 14 && hour <= 18) {
                    insights.push(`‚òÄÔ∏è Hor√°rio de alta atividade (14:00-18:00 UTC). Mais oportunidades mas maior competi√ß√£o.`);
                }

                return insights;
            }

            optimizeSettings() {
                if (document.getElementById('autoAdjust').value !== 'enabled') return;

                const successRate = state.stats.opportunitiesFound > 0 
                    ? (state.stats.successfulTrades / state.stats.opportunitiesFound)
                    : 0;

                // Auto-ajustar par√¢metros baseado em performance
                if (successRate < 0.3 && state.stats.opportunitiesFound > 10) {
                    // Performance baixa - ser mais conservador
                    const currentMinProfit = parseFloat(document.getElementById('minProfit').value);
                    if (currentMinProfit < 0.5) {
                        document.getElementById('minProfit').value = (currentMinProfit + 0.1).toFixed(1);
                        log('ü§ñ IA ajustou lucro m√≠nimo para ' + document.getElementById('minProfit').value + '%', 'ai');
                    }
                } else if (successRate > 0.7 && state.stats.successfulTrades > 5) {
                    // Performance alta - ser mais agressivo
                    const currentMinProfit = parseFloat(document.getElementById('minProfit').value);
                    if (currentMinProfit > 0.2) {
                        document.getElementById('minProfit').value = (currentMinProfit - 0.05).toFixed(2);
                        log('ü§ñ IA ajustou lucro m√≠nimo para ' + document.getElementById('minProfit').value + '%', 'ai');
                    }
                }
            }
        }

        // ========== FUN√á√ïES DE LOG ==========
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;

            // Limitar log a 100 entradas
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        function updateStats() {
            document.getElementById('totalScans').textContent = state.stats.totalScans;
            document.getElementById('routesScanned').textContent = state.stats.routesScanned.toLocaleString();
            document.getElementById('opportunitiesFound').textContent = state.stats.opportunitiesFound;
            document.getElementById('successfulTrades').textContent = state.stats.successfulTrades;
            document.getElementById('totalProfit').textContent = state.stats.totalProfit.toFixed(4);
            
            if (state.stats.aiPredictions > 0) {
                const accuracy = (state.stats.aiCorrect / state.stats.aiPredictions * 100).toFixed(1);
                document.getElementById('aiAccuracy').textContent = accuracy + '%';
            }
        }

        // ========== CONEX√ÉO WALLET ==========
        async function connectWallet() {
            try {
                log('Conectando carteira...', 'info');
                
                if (typeof window.ethereum === 'undefined') {
                    throw new Error('MetaMask n√£o encontrada! Instale em metamask.io');
                }

                const provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                const signer = provider.getSigner();
                const address = await signer.getAddress();

                state.provider = provider;
                state.signer = signer;
                state.wallet = address;

                document.getElementById('walletAddress').value = address;
                document.getElementById('connectionStatus').className = 'status connected';
                document.getElementById('connectionStatus').textContent = 'Conectado';
                document.getElementById('startBtn').disabled = false;

                log(`‚úÖ Carteira conectada: ${address.substring(0, 10)}...`, 'success');
                
                const balance = await provider.getBalance(address);
                const ethBalance = ethers.utils.formatEther(balance);
                log(`üí∞ Saldo: ${parseFloat(ethBalance).toFixed(4)} ETH`, 'success');

                // Inicializar IA
                if (!state.ai) {
                    state.ai = new ArbitrageAI();
                    await state.ai.initialize();
                }

            } catch (error) {
                log(`‚ùå Erro ao conectar: ${error.message}`, 'error');
            }
        }

        // ========== GERADOR DE ROTAS INTELIGENTE ==========
        function generateIntelligentRoutes(count) {
            const routes = [];
            const mode = document.getElementById('aiMode').value;
            
            // Ajustar par√¢metros baseado no modo
            let maxSwaps, minSwaps, preferredDexs;
            
            if (mode === 'conservative') {
                minSwaps = 2;
                maxSwaps = 3;
                preferredDexs = CONFIG.DEXS.filter(d => d.fee <= 0.003);
            } else if (mode === 'aggressive') {
                minSwaps = 2;
                maxSwaps = 4;
                preferredDexs = CONFIG.DEXS;
            } else {
                minSwaps = 2;
                maxSwaps = 3;
                preferredDexs = CONFIG.DEXS;
            }
            
            for (let i = 0; i < count; i++) {
                const swapCount = minSwaps + Math.floor(Math.random() * (maxSwaps - minSwaps + 1));
                const swaps = [];
                const usedDexs = new Set();
                
                let currentToken = CONFIG.TOKENS[0]; // WETH
                let totalFees = 0;
                let totalVolatility = 0;
                
                for (let j = 0; j < swapCount; j++) {
                    let nextToken;
                    do {
                        nextToken = CONFIG.TOKENS[Math.floor(Math.random() * CONFIG.TOKENS.length)];
                    } while (nextToken.address === currentToken.address);
                    
                    const dex = preferredDexs[Math.floor(Math.random() * preferredDexs.length)];
                    usedDexs.add(dex.name);
                    
                    swaps.push({
                        dex: dex.name,
                        router: dex.router,
                        tokenIn: currentToken.address,
                        tokenOut: nextToken.address,
                        symbolIn: currentToken.symbol,
                        symbolOut: nextToken.symbol,
                        fee: dex.fee
                    });
                    
                    totalFees += dex.fee;
                    totalVolatility += (currentToken.volatility + nextToken.volatility) / 2;
                    currentToken = nextToken;
                }
                
                // Fechar loop para WETH
                if (currentToken.address !== CONFIG.TOKENS[0].address) {
                    const dex = preferredDexs[Math.floor(Math.random() * preferredDexs.length)];
                    swaps.push({
                        dex: dex.name,
                        router: dex.router,
                        tokenIn: currentToken.address,
                        tokenOut: CONFIG.TOKENS[0].address,
                        symbolIn: currentToken.symbol,
                        symbolOut: 'WETH',
                        fee: dex.fee
                    });
                    totalFees += dex.fee;
                }
                
                routes.push({
                    id: i,
                    swaps: swaps,
                    description: swaps.map(s => `${s.symbolIn}‚Üí${s.symbolOut} (${s.dex})`).join(' ‚Üí '),
                    totalFees: totalFees,
                    dexDiversity: usedDexs.size / CONFIG.DEXS.length,
                    tokenVolatility: totalVolatility / swaps.length,
                    competitionLevel: Math.random(),
                    liquidityScore: Math.random()
                });
            }
            
            return routes;
        }

        // ========== SCANNING COM IA ==========
        async function startScanning() {
            if (state.isScanning) return;
            
            state.isScanning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('connectionStatus').className = 'status learning';
            document.getElementById('connectionStatus').textContent = 'IA Ativa';
            
            log('ü§ñ Iniciando sistema aut√¥nomo com IA...', 'ai');
            
            const tradeAmount = parseFloat(document.getElementById('tradeAmount').value);
            const minProfit = parseFloat(document.getElementById('minProfit').value);
            const workerCount = parseInt(document.getElementById('workerCount').value);
            
            while (state.isScanning) {
                const scanStartTime = Date.now();
                
                // IA otimiza n√∫mero de rotas baseado em performance
                let routeCount = 1000;
                if (state.stats.totalScans > 5) {
                    const avgSpeed = state.stats.routesScanned / state.stats.totalScans;
                    routeCount = Math.floor(avgSpeed * 1.5);
                }
                
                // Gerar rotas inteligentes
                const routes = generateIntelligentRoutes(routeCount);
                
                log(`üîÑ Scanning ${routeCount} rotas com IA (${workerCount} workers)...`, 'info');
                
                // Processar rotas
                const opportunities = [];
                for (let i = 0; i < routes.length; i++) {
                    const route = routes[i];
                    const profit = await calculateProfit(route, tradeAmount);
                    
                    if (profit.profitPercent >= minProfit) {
                        const opportunity = {
                            route: route,
                            profit: profit.profitEth,
                            profitPercent: profit.profitPercent,
                            gasEstimate: profit.gasEstimate,
                            dexDiversity: route.dexDiversity,
                            tokenVolatility: route.tokenVolatility,
                            liquidityScore: route.liquidityScore,
                            competitionLevel: route.competitionLevel,
                            timeOfDay: new Date().getHours() / 24,
                            gasPrice: 20,
                            slippageRisk: Math.random()
                        };
                        
                        // IA avalia oportunidade
                        if (state.ai) {
                            const prediction = await state.ai.predict(opportunity);
                            opportunity.aiPrediction = prediction;
                            
                            if (prediction.recommended) {
                                opportunities.push(opportunity);
                            }
                        } else {
                            opportunities.push(opportunity);
                        }
                    }
                    
                    // Update progress
                    if (i % 100 === 0) {
                        const progress = Math.floor((i / routes.length) * 100);
                        document.getElementById('scanProgress').style.width = progress + '%';
                        document.getElementById('scanProgress').textContent = progress + '%';
                    }
                }
                
                state.stats.totalScans++;
                state.stats.routesScanned += routeCount;
                
                if (opportunities.length > 0) {
                    state.stats.opportunitiesFound += opportunities.length;
                    
                    opportunities.sort((a, b) => {
                        // Ordenar por confian√ßa da IA e lucro
                        const scoreA = (a.aiPrediction?.confidence || 50) * a.profitPercent;
                        const scoreB = (b.aiPrediction?.confidence || 50) * b.profitPercent;
                        return scoreB - scoreA;
                    });
                    
                    displayOpportunities(opportunities.slice(0, 5));
                    
                    log(`üí∞ IA encontrou ${opportunities.length} oportunidades de alta confian√ßa!`, 'success');
                    
                    // Executar melhor oportunidade
                    if (opportunities[0].aiPrediction?.recommended) {
                        await executeArbitrage(opportunities[0]);
                    }
                } else {
                    log(`‚ÑπÔ∏è IA n√£o encontrou oportunidades com alta confian√ßa`, 'info');
                }
                
                // Atualizar insights
                updateAIInsights();
                
                // IA otimiza configura√ß√µes
                if (state.ai) {
                    state.ai.optimizeSettings();
                }
                
                const scanTime = (Date.now() - scanStartTime) / 1000;
                const speed = Math.floor(routeCount / scanTime);
                document.getElementById('scanSpeed').textContent = speed.toLocaleString();
                
                updateStats();
                
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
        }

        function stopScanning() {
            state.isScanning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('connectionStatus').className = 'status connected';
            document.getElementById('connectionStatus').textContent = 'Conectado';
            log('‚èπÔ∏è Sistema aut√¥nomo parado', 'warning');
        }

        // ========== C√ÅLCULO DE LUCRO ==========
        async function calculateProfit(route, amount) {
            const baseGasPrice = 20;
            const randomFactor = 0.95 + Math.random() * 0.1;
            
            const totalFees = route.totalFees || (route.swaps.length * 0.003);
            
            const outputAmount = amount * randomFactor * (1 - totalFees);
            const profitEth = outputAmount - amount;
            const profitPercent = (profitEth / amount) * 100;
            
            const gasEstimate = 150000 * route.swaps.length;
            const gasCost = (gasEstimate * baseGasPrice) / 1e9;
            
            return {
                profitEth: profitEth - gasCost,
                profitPercent: profitPercent,
                gasEstimate: gasEstimate
            };
        }

        // ========== EXIBIR OPORTUNIDADES ==========
        function displayOpportunities(opportunities) {
            const container = document.getElementById('opportunitiesList');
            container.innerHTML = '';
            
            opportunities.forEach((opp) => {
                const aiInfo = opp.aiPrediction 
                    ? `ü§ñ IA: ${(opp.aiPrediction.confidence).toFixed(0)}% confian√ßa, ${(opp.aiPrediction.success * 100).toFixed(0)}% sucesso previsto`
                    : 'ü§ñ IA: Analisando...';
                
                const oppDiv = document.createElement('div');
                oppDiv.className = 'opportunity';
                oppDiv.innerHTML = `
                    <div class="opportunity-profit">
                        +${opp.profit.toFixed(6)} ETH (${opp.profitPercent.toFixed(2)}%)
                    </div>
                    <div class="opportunity-route">
                        ${opp.route.description}
                    </div>
                    <div class="opportunity-ai">
                        ${aiInfo}
                    </div>
                    <div style="font-size: 0.8em; color: #a0a0ff; margin-top: 5px;">
                        Gas: ${opp.gasEstimate.toLocaleString()} | Diversidade DEX: ${(opp.dexDiversity * 100).toFixed(0)}%
                    </div>
                `;
                container.appendChild(oppDiv);
            });
        }

        // ========== EXECU√á√ÉO ==========
        async function executeArbitrage(opportunity) {
            try {
                log(`üéØ Executando arbitragem: ${opportunity.route.description}`, 'warning');
                log(`üíµ Lucro esperado: +${opportunity.profit.toFixed(6)} ETH (${opportunity.profitPercent.toFixed(2)}%)`, 'warning');
                log(`ü§ñ Confian√ßa IA: ${opportunity.aiPrediction?.confidence.toFixed(0)}%`, 'ai');
                
                const success = Math.random() > 0.25;
                
                if (success) {
                    const actualProfit = opportunity.profit * (0.9 + Math.random() * 0.2);
                    state.stats.successfulTrades++;
                    state.stats.totalProfit += actualProfit;
                    
                    // Registrar na IA
                    if (state.ai) {
                        state.ai.recordResult(opportunity, true);
                    }
                    
                    // Adicionar √†s melhores rotas
                    state.bestRoutes.push({
                        ...opportunity.route,
                        profit: actualProfit
                    });
                    state.bestRoutes.sort((a, b) => b.profit - a.profit);
                    state.bestRoutes = state.bestRoutes.slice(0, 10);
                    
                    log(`‚úÖ Arbitragem executada! Lucro: +${actualProfit.toFixed(6)} ETH`, 'success');
                } else {
                    if (state.ai) {
                        state.ai.recordResult(opportunity, false);
                    }
                    log(`‚ùå Arbitragem falhou`, 'error');
                }
                
                updateStats();
                
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
            }
        }

        // ========== INSIGHTS IA ==========
        function updateAIInsights() {
            if (!state.ai) return;
            
            const insights = state.ai.analyzeMarketConditions();
            const container = document.getElementById('insightsList');
            container.innerHTML = '';
            
            if (insights.length === 0) {
                container.innerHTML = '<div class="ai-insight-item">‚è≥ Coletando dados...</div>';
                return;
            }
            
            insights.forEach(insight => {
                const item = document.createElement('div');
                item.className = 'ai-insight-item';
                item.textContent = insight;
                container.appendChild(item);
            });
        }

        // ========== TREINAR IA ==========
        async function trainAI() {
            if (!state.ai) {
                log('‚ùå IA n√£o inicializada', 'error');
                return;
            }
            
            log('üéì Iniciando treinamento da IA...', 'ai');
            
            // Gerar dados de treinamento simulados
            const trainingData = [];
            for (let i = 0; i < 100; i++) {
                const route = generateIntelligentRoutes(1)[0];
                const profit = await calculateProfit(route, 0.005);
                
                const opportunity = {
                    route: route,
                    profit: profit.profitEth,
                    profitPercent: profit.profitPercent,
                    gasEstimate: profit.gasEstimate,
                    dexDiversity: route.dexDiversity,
                    tokenVolatility: route.tokenVolatility,
                    liquidityScore: route.liquidityScore,
                    competitionLevel: route.competitionLevel,
                    timeOfDay: Math.random(),
                    gasPrice: 20,
                    slippageRisk: Math.random()
                };
                
                const success = profit.profitPercent > 0.5 && Math.random() > 0.3;
                
                trainingData.push({
                    opportunity: opportunity,
                    success: success
                });
            }
            
            await state.ai.train(trainingData);
            updateAIInsights();
        }

        // ========== EVENT LISTENERS ==========
        document.getElementById('connectBtn').addEventListener('click', connectWallet);
        document.getElementById('startBtn').addEventListener('click', startScanning);
        document.getElementById('stopBtn').addEventListener('click', stopScanning);
        document.getElementById('trainBtn').addEventListener('click', trainAI);

        // ========== INICIALIZA√á√ÉO ==========
        window.addEventListener('load', async () => {
            log('ü§ñ FlashArb AI iniciado!', 'success');
            log('üß† Sistema de aprendizado aut√¥nomo carregado', 'ai');
            log('üìù Conecte sua carteira para come√ßar', 'info');
        });
    </script>
</body>
</html>
