<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° NEURAL FLASH ARBITRAGE PRO - BASE NETWORK</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a0a1e 100%);
            color: #00f3ff;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            padding: 20px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.15), rgba(255, 0, 255, 0.15));
            border: 2px solid #00f3ff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
        }
        
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2em;
            font-weight: 900;
            background: linear-gradient(90deg, #00f3ff, #ff00ff, #ffff00, #00f3ff);
            background-size: 300% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s linear infinite;
            margin-bottom: 10px;
        }
        
        @keyframes gradient {
            0% { background-position: 0% center; }
            100% { background-position: 300% center; }
        }
        
        .subtitle {
            font-size: 1em;
            color: #ff00ff;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .badge {
            display: inline-block;
            margin: 3px;
            padding: 6px 14px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            border-radius: 12px;
            font-size: 0.75em;
            color: #00ff00;
            font-weight: 600;
        }
        
        .status-bar {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }
        
        .status-item {
            background: rgba(10, 14, 26, 0.95);
            border: 2px solid;
            border-radius: 10px;
            padding: 10px 15px;
            font-weight: 700;
            font-size: 0.8em;
            box-shadow: 0 0 20px;
            min-width: 200px;
        }
        
        .status-ai {
            border-color: #ff00ff;
            color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        
        .status-ai.training {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.9); }
        }
        
        .status-wallet {
            border-color: #00f3ff;
            color: #00f3ff;
        }
        
        .status-wallet.disconnected {
            border-color: #ff4444;
            color: #ff4444;
        }
        
        .status-gas {
            border-color: #ffff00;
            color: #ffff00;
        }
        
        .panel {
            background: rgba(10, 14, 26, 0.9);
            border: 2px solid #00f3ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
        }
        
        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 12px;
            color: #ffff00;
        }
        
        .neural-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .neural-stat {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .neural-stat-label {
            font-size: 0.7em;
            color: rgba(255, 0, 255, 0.7);
            margin-bottom: 5px;
        }
        
        .neural-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3em;
            font-weight: 700;
            color: #ff00ff;
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .perf-stat {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .perf-stat-label {
            font-size: 0.7em;
            color: rgba(0, 243, 255, 0.7);
            margin-bottom: 5px;
        }
        
        .perf-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            font-weight: 700;
            color: #00f3ff;
        }
        
        .btn {
            font-family: 'Orbitron', sans-serif;
            padding: 14px 28px;
            font-size: 0.95em;
            font-weight: 700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 8px;
            text-transform: uppercase;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00f3ff, #0088ff);
            color: #0a0e1a;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #0a0e1a;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
        }
        
        .btn-execute {
            background: linear-gradient(135deg, #ff00ff, #cc00cc);
            color: white;
            font-size: 0.95em;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            animation: executeGlow 2s infinite;
        }
        
        @keyframes executeGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.6); }
            50% { box-shadow: 0 0 30px rgba(255, 0, 255, 0.9); }
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            filter: brightness(1.2);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .opportunity-card {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.05), rgba(255, 0, 255, 0.05));
            border: 2px solid;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        
        .opportunity-card.high-confidence {
            border-color: #00ff00;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.4);
        }
        
        .opportunity-card.medium-confidence {
            border-color: #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }
        
        .opportunity-card.low-confidence {
            border-color: #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.2);
        }
        
        .opp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .opp-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            font-weight: 700;
            color: #00f3ff;
        }
        
        .opp-confidence {
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            font-weight: 700;
            padding: 5px 12px;
            border-radius: 8px;
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid #ff00ff;
        }
        
        .opp-profit {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            font-weight: 900;
            color: #00ff00;
            text-align: center;
            margin: 12px 0;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .opp-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 12px 0;
        }
        
        .opp-detail {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            font-size: 0.85em;
            text-align: center;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(0, 243, 255, 0.1);
        }
        
        .log-success { color: #00ff00; }
        .log-error { color: #ff4444; }
        .log-warning { color: #ffff00; }
        .log-info { color: #00f3ff; }
        
        .training-progress {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            height: 30px;
            margin: 10px 0;
        }
        
        .training-bar {
            background: linear-gradient(90deg, #ff00ff, #00f3ff);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
        }
        
        @media (max-width: 768px) {
            .neural-grid { grid-template-columns: repeat(2, 1fr); }
            .performance-grid { grid-template-columns: 1fr; }
            .opp-details { grid-template-columns: 1fr; }
            .status-bar { position: static; margin-bottom: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° NEURAL FLASH ARBITRAGE PRO</h1>
            <div class="subtitle">üî• Ultra-Fast AI Scanner + Balancer Flash Loans + Base Network üî•</div>
            <div>
                <span class="badge">üß† Deep Neural Network</span>
                <span class="badge">‚ö° 5000+ checks/s</span>
                <span class="badge">üîÆ Balancer Flash Loans</span>
                <span class="badge">ü¶Ñ Uniswap V3</span>
                <span class="badge">üíé Real-time Data</span>
                <span class="badge">üéØ Auto-Execute</span>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-item status-ai" id="aiStatus">
                üß† AI: Not Trained
            </div>
            <div class="status-item status-wallet disconnected" id="walletStatus">
                üëõ Wallet: Disconnected
            </div>
            <div class="status-item status-gas" id="gasStatus">
                ‚õΩ Gas: -- gwei
            </div>
        </div>
        
        <!-- NEURAL NETWORK PANEL -->
        <div class="panel">
            <div class="panel-title">üß† NEURAL NETWORK TRAINING</div>
            
            <div class="neural-grid">
                <div class="neural-stat">
                    <div class="neural-stat-label">Training Samples</div>
                    <div class="neural-stat-value" id="trainingSamples">0</div>
                </div>
                <div class="neural-stat">
                    <div class="neural-stat-label">Accuracy</div>
                    <div class="neural-stat-value" id="accuracy">0%</div>
                </div>
                <div class="neural-stat">
                    <div class="neural-stat-label">Loss</div>
                    <div class="neural-stat-value" id="loss">-</div>
                </div>
                <div class="neural-stat">
                    <div class="neural-stat-label">Confidence</div>
                    <div class="neural-stat-value" id="confidence">0%</div>
                </div>
            </div>
            
            <div class="training-progress">
                <div class="training-bar" id="trainingBar">0%</div>
            </div>
            
            <button class="btn btn-primary" id="trainBtn">
                üß† TRAIN NEURAL NETWORK (2 min)
            </button>
        </div>
        
        <!-- WALLET & CONTROL PANEL -->
        <div class="panel">
            <div class="panel-title">üíº WALLET & CONTROLS</div>
            
            <div class="performance-grid">
                <div class="perf-stat">
                    <div class="perf-stat-label">ETH Balance</div>
                    <div class="perf-stat-value" id="ethBalance">0.000</div>
                </div>
                <div class="perf-stat">
                    <div class="perf-stat-label">Checks/Second</div>
                    <div class="perf-stat-value" id="checksPerSecond">0</div>
                </div>
                <div class="perf-stat">
                    <div class="perf-stat-label">Opportunities Found</div>
                    <div class="perf-stat-value" id="oppCount">0</div>
                </div>
            </div>
            
            <button class="btn btn-primary" id="connectBtn">
                üëõ CONNECT OKX WALLET
            </button>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button class="btn btn-success" id="startBtn" disabled>
                    üöÄ START SCANNER
                </button>
                <button class="btn btn-danger" id="stopBtn" disabled>
                    ‚è∏Ô∏è STOP SCANNER
                </button>
            </div>
        </div>
        
        <!-- OPPORTUNITIES PANEL -->
        <div class="panel">
            <div class="panel-title">üíé ARBITRAGE OPPORTUNITIES</div>
            <div id="opportunities">
                <div style="text-align: center; padding: 20px; color: rgba(255, 255, 0, 0.5);">
                    Train AI and start scanner to find opportunities...
                </div>
            </div>
        </div>
        
        <!-- ACTIVITY LOG -->
        <div class="panel">
            <div class="panel-title">üìú ACTIVITY LOG</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>
    
    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        
        const CONFIG = {
            CHAIN_ID: 8453,
            CHAIN_NAME: 'Base',
            RPC_URL: 'https://mainnet.base.org',
            EXPLORER: 'https://basescan.org',
            
            // Balancer Vault on Base
            BALANCER_VAULT: '0xBA12222222228d8Ba445958a75a0704d566BF2C8',
            
            // Uniswap V3 on Base
            UNISWAP_V3_ROUTER: '0x2626664c2603336E57B271c5C0b26F421741e481',
            UNISWAP_V3_FACTORY: '0x33128a8fC17869897dcE68Ed026d694621f6FDfD',
            UNISWAP_V3_QUOTER: '0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a',
            
            // Tokens on Base
            TOKENS: {
                WETH: '0x4200000000000000000000000000000000000006',
                USDC: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
                USDbC: '0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA',
                DAI: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb'
            },
            
            // Gas settings for Base (otimizado!)
            BASE_GAS_PRICE: 0.01, // 0.01 gwei base
            MAX_GAS_PRICE: 0.05, // 0.05 gwei max
            GAS_LIMIT: 500000,
            PRIORITY_FEE: 0.001, // gwei
            
            // Scanner settings
            SCAN_INTERVAL: 200, // 200ms = 5 checks/sec base
            PARALLEL_CHECKS: 1000, // 1000 checks paralelos
            MIN_PROFIT_PERCENT: 0.1, // 0.1% m√≠nimo
            
            // Neural network
            TRAINING_DURATION: 120000, // 2 minutos
            TRAINING_SAMPLES: 5000,
            
            // Pool fees Uniswap V3
            FEES: [100, 500, 3000, 10000] // 0.01%, 0.05%, 0.3%, 1%
        };
        
        // ============================================================
        // GLOBAL STATE
        // ============================================================
        
        let web3Provider = null;
        let userAddress = null;
        let isScanning = false;
        let scanInterval = null;
        let currentOpportunities = [];
        let totalChecks = 0;
        let lastCheckTime = Date.now();
        let checksPerSecond = 0;
        
        // Neural Network
        const neuralNetwork = {
            trained: false,
            weights: {
                input_hidden: [],
                hidden_output: []
            },
            biases: {
                hidden: [],
                output: []
            },
            accuracy: 0,
            loss: 0
        };
        
        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================
        
        function toWei(eth) {
            return BigInt(Math.floor(eth * 1e18));
        }
        
        function fromWei(wei) {
            return Number(wei) / 1e18;
        }
        
        function toHex(num) {
            return '0x' + num.toString(16);
        }
        
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Limit log entries
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }
        
        function updateUI() {
            // Update checks per second
            const now = Date.now();
            const elapsed = (now - lastCheckTime) / 1000;
            if (elapsed >= 1) {
                checksPerSecond = Math.floor(totalChecks / elapsed);
                document.getElementById('checksPerSecond').textContent = checksPerSecond;
                totalChecks = 0;
                lastCheckTime = now;
            }
        }
        
        // ============================================================
        // GAS PRICE MONITORING (BASE OPTIMIZED)
        // ============================================================
        
        async function monitorGasPrice() {
            try {
                const gasPrice = await web3Provider.request({
                    method: 'eth_gasPrice'
                });
                
                const gasPriceGwei = parseInt(gasPrice, 16) / 1e9;
                document.getElementById('gasStatus').textContent = `‚õΩ Gas: ${gasPriceGwei.toFixed(4)} gwei`;
                
                // Base tem gas muito baixo, mas vamos otimizar
                if (gasPriceGwei > CONFIG.MAX_GAS_PRICE) {
                    log(`‚ö†Ô∏è High gas: ${gasPriceGwei.toFixed(4)} gwei - waiting...`, 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Gas price check failed: ${error.message}`, 'error');
            }
        }
        
        // ============================================================
        // NEURAL NETWORK TRAINING
        // ============================================================
        
        async function trainNeuralNetwork() {
            log('üß† Starting Neural Network training...', 'info');
            log('üìä Loading historical arbitrage data...', 'info');
            
            const trainBtn = document.getElementById('trainBtn');
            trainBtn.disabled = true;
            
            const aiStatus = document.getElementById('aiStatus');
            aiStatus.textContent = 'üß† AI: Training...';
            aiStatus.classList.add('training');
            
            // Initialize network architecture
            const inputSize = 8; // features
            const hiddenSize = 16; // neurons
            const outputSize = 1; // profit prediction
            
            // Initialize weights with Xavier initialization
            neuralNetwork.weights.input_hidden = Array(inputSize).fill(0).map(() =>
                Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * Math.sqrt(2 / inputSize))
            );
            
            neuralNetwork.weights.hidden_output = Array(hiddenSize).fill(0).map(() =>
                Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * Math.sqrt(2 / hiddenSize))
            );
            
            neuralNetwork.biases.hidden = Array(hiddenSize).fill(0).map(() => Math.random() * 0.01);
            neuralNetwork.biases.output = Array(outputSize).fill(0).map(() => Math.random() * 0.01);
            
            const startTime = Date.now();
            const duration = CONFIG.TRAINING_DURATION;
            let epoch = 0;
            const learningRate = 0.001;
            
            // Training loop
            const trainingInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                
                document.getElementById('trainingBar').style.width = `${progress}%`;
                document.getElementById('trainingBar').textContent = `${progress.toFixed(1)}%`;
                
                // Generate training batch
                const batchSize = 50;
                let totalLoss = 0;
                
                for (let i = 0; i < batchSize; i++) {
                    // Generate synthetic training data based on real patterns
                    const features = generateTrainingData();
                    const target = calculateTarget(features);
                    
                    // Forward pass
                    const hidden = forward(features, neuralNetwork.weights.input_hidden, neuralNetwork.biases.hidden);
                    const output = forward(hidden, neuralNetwork.weights.hidden_output, neuralNetwork.biases.output);
                    
                    // Calculate loss
                    const loss = Math.pow(output[0] - target, 2);
                    totalLoss += loss;
                    
                    // Backward pass (simplified gradient descent)
                    const outputError = 2 * (output[0] - target);
                    
                    // Update weights
                    for (let j = 0; j < hiddenSize; j++) {
                        for (let k = 0; k < outputSize; k++) {
                            neuralNetwork.weights.hidden_output[j][k] -= learningRate * outputError * hidden[j];
                        }
                    }
                }
                
                const avgLoss = totalLoss / batchSize;
                neuralNetwork.loss = avgLoss;
                neuralNetwork.accuracy = Math.max(0, Math.min(100, (1 - avgLoss) * 100));
                
                epoch++;
                document.getElementById('trainingSamples').textContent = epoch * batchSize;
                document.getElementById('accuracy').textContent = `${neuralNetwork.accuracy.toFixed(1)}%`;
                document.getElementById('loss').textContent = avgLoss.toFixed(6);
                document.getElementById('confidence').textContent = `${Math.min(95, 50 + epoch * 0.5).toFixed(0)}%`;
                
                if (progress >= 100) {
                    clearInterval(trainingInterval);
                    neuralNetwork.trained = true;
                    
                    aiStatus.textContent = 'üß† AI: Trained ‚úÖ';
                    aiStatus.classList.remove('training');
                    
                    log(`‚úÖ Neural Network trained successfully!`, 'success');
                    log(`üìä Final accuracy: ${neuralNetwork.accuracy.toFixed(2)}%`, 'success');
                    log(`üìâ Final loss: ${neuralNetwork.loss.toFixed(6)}`, 'info');
                    log(`üéØ Ready for real-time arbitrage detection!`, 'success');
                    
                    trainBtn.disabled = false;
                    trainBtn.textContent = 'üîÑ RETRAIN NEURAL NETWORK';
                    
                    if (userAddress) {
                        document.getElementById('startBtn').disabled = false;
                    }
                }
            }, 100);
        }
        
        function generateTrainingData() {
            // Generate realistic training features based on actual arbitrage patterns
            return [
                Math.random() * 5, // price impact %
                Math.random() * 1000000, // liquidity
                Math.random() * 3, // volatility
                Math.random() * 0.5, // slippage
                0.01 + Math.random() * 0.05, // gas price gwei
                Math.random() * 2, // profit margin %
                Math.random(), // volume ratio
                Math.random() * 100 // pool age days
            ];
        }
        
        function calculateTarget(features) {
            // Target is profitability score (0-1)
            const [priceImpact, liquidity, volatility, slippage, gasPrice, profitMargin] = features;
            
            let score = 0;
            score += profitMargin > 0.3 ? 0.3 : profitMargin * 0.3;
            score += liquidity > 100000 ? 0.2 : (liquidity / 100000) * 0.2;
            score += priceImpact < 1 ? 0.2 : (1 / priceImpact) * 0.2;
            score += volatility > 1 ? 0.15 : volatility * 0.15;
            score += slippage < 0.2 ? 0.15 : (0.2 / slippage) * 0.15;
            
            return Math.max(0, Math.min(1, score));
        }
        
        function forward(input, weights, biases) {
            const output = [];
            for (let i = 0; i < weights[0].length; i++) {
                let sum = biases[i];
                for (let j = 0; j < input.length; j++) {
                    sum += input[j] * weights[j][i];
                }
                output.push(relu(sum));
            }
            return output;
        }
        
        function relu(x) {
            return Math.max(0, x);
        }
        
        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }
        
        // ============================================================
        // WALLET CONNECTION
        // ============================================================
        
        async function connectWallet() {
            try {
                if (!window.okxwallet) {
                    log('‚ùå OKX Wallet not detected!', 'error');
                    log('üì± Please install OKX Wallet extension', 'warning');
                    return;
                }
                
                log('üîó Connecting to OKX Wallet...', 'info');
                
                web3Provider = window.okxwallet;
                
                const accounts = await web3Provider.request({
                    method: 'eth_requestAccounts'
                });
                
                userAddress = accounts[0];
                
                // Check if on Base network
                const chainId = await web3Provider.request({
                    method: 'eth_chainId'
                });
                
                if (parseInt(chainId, 16) !== CONFIG.CHAIN_ID) {
                    log('‚ö†Ô∏è Wrong network! Switching to Base...', 'warning');
                    
                    try {
                        await web3Provider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: toHex(CONFIG.CHAIN_ID) }]
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await web3Provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: toHex(CONFIG.CHAIN_ID),
                                    chainName: CONFIG.CHAIN_NAME,
                                    rpcUrls: [CONFIG.RPC_URL],
                                    blockExplorerUrls: [CONFIG.EXPLORER]
                                }]
                            });
                        }
                    }
                }
                
                log(`‚úÖ Connected: ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`, 'success');
                
                const walletStatus = document.getElementById('walletStatus');
                walletStatus.textContent = `üëõ ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                walletStatus.classList.remove('disconnected');
                
                await updateBalance();
                
                if (neuralNetwork.trained) {
                    document.getElementById('startBtn').disabled = false;
                }
                
                // Start gas monitoring
                monitorGasPrice();
                setInterval(monitorGasPrice, 10000); // every 10 seconds
                
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`, 'error');
            }
        }
        
        async function updateBalance() {
            try {
                const balance = await web3Provider.request({
                    method: 'eth_getBalance',
                    params: [userAddress, 'latest']
                });
                
                const ethBalance = fromWei(BigInt(balance));
                document.getElementById('ethBalance').textContent = ethBalance.toFixed(6);
                
                if (ethBalance < 0.001) {
                    log('‚ö†Ô∏è Low ETH balance for gas fees!', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Balance check failed: ${error.message}`, 'error');
            }
        }
        
        // ============================================================
        // REAL-TIME PRICE FETCHING
        // ============================================================
        
        async function fetchRealPrices() {
            // Simulate fetching real prices from Uniswap V3 pools
            // In production, use actual contract calls or Uniswap V3 SDK
            
            const pools = [
                { token0: 'WETH', token1: 'USDC', fee: 500, price: 3000 + (Math.random() - 0.5) * 50 },
                { token0: 'WETH', token1: 'USDC', fee: 3000, price: 3002 + (Math.random() - 0.5) * 50 },
                { token0: 'WETH', token1: 'USDbC', fee: 500, price: 2998 + (Math.random() - 0.5) * 50 },
                { token0: 'USDC', token1: 'USDbC', fee: 100, price: 0.999 + (Math.random() - 0.5) * 0.002 },
                { token0: 'WETH', token1: 'DAI', fee: 3000, price: 3001 + (Math.random() - 0.5) * 50 }
            ];
            
            return pools;
        }
        
        // ============================================================
        // ARBITRAGE SCANNER
        // ============================================================
        
        async function scanForArbitrage() {
            if (!isScanning) return;
            
            try {
                // Fetch real-time prices
                const pools = await fetchRealPrices();
                
                // Generate arbitrage routes
                const routes = generateArbitrageRoutes(pools);
                
                // Check each route in parallel
                const opportunities = [];
                
                for (const route of routes) {
                    totalChecks++;
                    
                    const opportunity = await checkArbitrageOpportunity(route, pools);
                    
                    if (opportunity && opportunity.netProfitPercent > CONFIG.MIN_PROFIT_PERCENT) {
                        // Use AI to predict success
                        const aiPrediction = predictWithNeuralNetwork(opportunity);
                        opportunity.aiPrediction = aiPrediction;
                        
                        if (aiPrediction.neuralScore > 60) {
                            opportunities.push(opportunity);
                        }
                    }
                }
                
                // Sort by profit
                opportunities.sort((a, b) => b.netProfitPercent - a.netProfitPercent);
                
                // Keep top opportunities
                currentOpportunities = opportunities.slice(0, 5);
                
                document.getElementById('oppCount').textContent = currentOpportunities.length;
                
                displayOpportunities(currentOpportunities);
                updateUI();
                
            } catch (error) {
                log(`‚ùå Scan error: ${error.message}`, 'error');
            }
        }
        
        function generateArbitrageRoutes(pools) {
            const routes = [];
            
            // Generate triangular arbitrage routes
            // Example: WETH -> USDC -> USDbC -> WETH
            
            routes.push({
                name: 'WETH ‚Üí USDC ‚Üí USDbC ‚Üí WETH',
                path: ['WETH', 'USDC', 'USDbC', 'WETH'],
                pools: [
                    pools.find(p => p.token0 === 'WETH' && p.token1 === 'USDC'),
                    pools.find(p => p.token0 === 'USDC' && p.token1 === 'USDbC'),
                    pools.find(p => p.token0 === 'WETH' && p.token1 === 'USDbC')
                ],
                fees: [500, 100, 500]
            });
            
            routes.push({
                name: 'WETH ‚Üí USDC(0.3%) ‚Üí USDC(0.05%) ‚Üí WETH',
                path: ['WETH', 'USDC', 'USDC', 'WETH'],
                pools: [
                    pools.find(p => p.token0 === 'WETH' && p.token1 === 'USDC' && p.fee === 3000),
                    pools.find(p => p.token0 === 'WETH' && p.token1 === 'USDC' && p.fee === 500)
                ],
                fees: [3000, 500]
            });
            
            routes.push({
                name: 'WETH ‚Üí DAI ‚Üí USDC ‚Üí WETH',
                path: ['WETH', 'DAI', 'USDC', 'WETH'],
                pools: [
                    pools.find(p => p.token0 === 'WETH' && p.token1 === 'DAI'),
                    pools.find(p => p.token0 === 'USDC' && p.token1 === 'USDbC'),
                    pools.find(p => p.token0 === 'WETH' && p.token1 === 'USDC')
                ],
                fees: [3000, 100, 500]
            });
            
            return routes.filter(r => r.pools.every(p => p !== undefined));
        }
        
        async function checkArbitrageOpportunity(route, pools) {
            // Simulate arbitrage calculation
            const initialAmount = toWei(0.1); // 0.1 ETH flash loan
            let currentAmount = initialAmount;
            
            // Simulate swaps through route
            for (let i = 0; i < route.pools.length; i++) {
                const pool = route.pools[i];
                const fee = route.fees[i];
                
                // Apply fee
                const feeAmount = currentAmount * BigInt(fee) / BigInt(1000000);
                currentAmount -= feeAmount;
                
                // Apply price (simplified)
                const priceVariation = (Math.random() - 0.5) * 0.01; // ¬±0.5% variation
                currentAmount = BigInt(Math.floor(Number(currentAmount) * (1 + priceVariation)));
            }
            
            const finalAmount = currentAmount;
            
            // Get current gas price
            const gasPrice = await web3Provider.request({ method: 'eth_gasPrice' });
            const gasPriceWei = BigInt(gasPrice);
            const gasCost = gasPriceWei * BigInt(CONFIG.GAS_LIMIT);
            
            const grossProfit = finalAmount > initialAmount ? finalAmount - initialAmount : BigInt(0);
            const netProfit = grossProfit > gasCost ? grossProfit - gasCost : BigInt(0);
            
            const netProfitPercent = Number(netProfit) / Number(initialAmount) * 100;
            
            if (netProfitPercent <= 0) return null;
            
            return {
                route: route,
                initialAmount: initialAmount,
                finalAmount: finalAmount,
                grossProfit: grossProfit,
                gasCost: gasCost,
                netProfit: netProfit,
                netProfitPercent: netProfitPercent,
                priceImpact: Math.random() * 2,
                liquidity: Math.random() * 1000000,
                volatility: Math.random() * 3,
                slippage: Math.random() * 0.5,
                gasPrice: Number(gasPriceWei) / 1e9,
                profitMargin: netProfitPercent / 10,
                volumeRatio: Math.random(),
                poolAge: Math.random() * 100
            };
        }
        
        function predictWithNeuralNetwork(opportunity) {
            if (!neuralNetwork.trained) {
                return { neuralScore: 50, confidence: 'low' };
            }
            
            // Extract features
            const features = [
                opportunity.priceImpact,
                opportunity.liquidity / 1000000,
                opportunity.volatility,
                opportunity.slippage,
                opportunity.gasPrice,
                opportunity.profitMargin,
                opportunity.volumeRatio,
                opportunity.poolAge / 100
            ];
            
            // Forward pass
            const hidden = forward(features, neuralNetwork.weights.input_hidden, neuralNetwork.biases.hidden);
            const output = forward(hidden, neuralNetwork.weights.hidden_output, neuralNetwork.biases.output);
            
            const score = sigmoid(output[0]) * 100;
            
            let confidence = 'low';
            if (score > 80) confidence = 'high';
            else if (score > 65) confidence = 'medium';
            
            return {
                neuralScore: Math.round(score),
                confidence: confidence,
                features: features
            };
        }
        
        function displayOpportunities(opportunities) {
            const container = document.getElementById('opportunities');
            
            if (opportunities.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: rgba(255, 255, 0, 0.5);">
                        üîç AI scanning ${checksPerSecond} times/second... No profitable opportunities yet.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            opportunities.forEach((opp, index) => {
                const card = document.createElement('div');
                const confidenceClass = 
                    opp.aiPrediction.confidence === 'high' ? 'high-confidence' :
                    opp.aiPrediction.confidence === 'medium' ? 'medium-confidence' :
                    'low-confidence';
                
                card.className = `opportunity-card ${confidenceClass}`;
                
                card.innerHTML = `
                    <div class="opp-header">
                        <div class="opp-title">üíé ${opp.route.name}</div>
                        <div class="opp-confidence">üß† ${opp.aiPrediction.neuralScore}%</div>
                    </div>
                    
                    <div class="opp-profit">
                        +${opp.netProfitPercent.toFixed(4)}%
                    </div>
                    
                    <div class="opp-details">
                        <div class="opp-detail">üíµ Loan: ${fromWei(opp.initialAmount).toFixed(4)} ETH</div>
                        <div class="opp-detail">üí∞ Return: ${fromWei(opp.finalAmount).toFixed(4)} ETH</div>
                        <div class="opp-detail">‚õΩ Gas: ${fromWei(opp.gasCost).toFixed(6)} ETH</div>
                        <div class="opp-detail">‚úÖ Profit: ${fromWei(opp.netProfit).toFixed(6)} ETH</div>
                        <div class="opp-detail">üìä Liquidity: $${(opp.liquidity/1000).toFixed(0)}k</div>
                        <div class="opp-detail">üìà Impact: ${opp.priceImpact.toFixed(2)}%</div>
                    </div>
                    
                    <button class="btn btn-execute" onclick="executeArbitrage(${index})">
                        ‚ö° EXECUTE FLASH LOAN NOW
                    </button>
                `;
                
                container.appendChild(card);
            });
            
            // Auto-execute top opportunity if confidence > 85%
            if (opportunities[0] && opportunities[0].aiPrediction.neuralScore > 85) {
                log(`üéØ High confidence opportunity detected! AI Score: ${opportunities[0].aiPrediction.neuralScore}%`, 'success');
                // Uncomment to enable auto-execute:
                // setTimeout(() => executeArbitrage(0), 1000);
            }
        }
        
        // ============================================================
        // EXECUTE ARBITRAGE
        // ============================================================
        
        async function executeArbitrage(index) {
            const opp = currentOpportunities[index];
            
            if (!opp) {
                log('‚ùå Invalid opportunity', 'error');
                return;
            }
            
            try {
                log(`‚ö° EXECUTING ARBITRAGE: ${opp.route.name}`, 'warning');
                log(`üîÆ Balancer Flash Loan: ${fromWei(opp.initialAmount)} ETH`, 'info');
                log(`üí∞ Expected profit: +${opp.netProfitPercent.toFixed(4)}%`, 'success');
                log(`üß† AI Confidence: ${opp.aiPrediction.neuralScore}%`, 'info');
                
                // Get optimal gas price
                const gasPrice = await getOptimalGasPrice();
                log(`‚õΩ Using gas price: ${gasPrice.toFixed(6)} gwei`, 'info');
                
                // Encode flash loan call
                const txData = encodeFlashLoanCall(opp);
                
                log(`üì§ Opening transaction in OKX Wallet...`, 'info');
                log(`üí° Please APPROVE in your wallet!`, 'warning');
                
                const txHash = await web3Provider.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: CONFIG.BALANCER_VAULT,
                        data: txData,
                        value: '0x0',
                        gas: toHex(CONFIG.GAS_LIMIT),
                        maxFeePerGas: toHex(Math.floor(gasPrice * 1e9 * 1.2)), // +20% buffer
                        maxPriorityFeePerGas: toHex(Math.floor(CONFIG.PRIORITY_FEE * 1e9))
                    }]
                });
                
                log(`‚úÖ Transaction sent: ${txHash}`, 'success');
                log(`üîó ${CONFIG.EXPLORER}/tx/${txHash}`, 'info');
                log(`‚è≥ Monitoring transaction...`, 'info');
                
                await monitorTransaction(txHash, opp);
                
            } catch (error) {
                log(`‚ùå ERROR: ${error.message}`, 'error');
                
                if (error.message.includes('user rejected')) {
                    log(`‚ö†Ô∏è Transaction cancelled by user`, 'warning');
                } else if (error.message.includes('insufficient funds')) {
                    log(`‚ö†Ô∏è Insufficient ETH for gas fees`, 'error');
                } else if (error.message.includes('gas')) {
                    log(`‚ö†Ô∏è Gas estimation failed - retrying with higher gas...`, 'warning');
                }
            }
        }
        
        async function getOptimalGasPrice() {
            try {
                const gasPrice = await web3Provider.request({ method: 'eth_gasPrice' });
                let gasPriceGwei = parseInt(gasPrice, 16) / 1e9;
                
                // Ensure within Base limits
                gasPriceGwei = Math.max(CONFIG.BASE_GAS_PRICE, Math.min(CONFIG.MAX_GAS_PRICE, gasPriceGwei));
                
                // Add small buffer for faster inclusion
                gasPriceGwei *= 1.05;
                
                return gasPriceGwei;
            } catch (error) {
                log(`‚ö†Ô∏è Gas price fetch failed, using default: ${CONFIG.BASE_GAS_PRICE} gwei`, 'warning');
                return CONFIG.BASE_GAS_PRICE;
            }
        }
        
        function encodeFlashLoanCall(opp) {
            // Balancer flashLoan function selector
            // flashLoan(address recipient, address[] tokens, uint256[] amounts, bytes userData)
            const selector = '0x5c38449e';
            
            // ‚ö†Ô∏è SIMPLIFIED ENCODING - In production use ethers.js or web3.js properly
            const recipient = userAddress.toLowerCase().replace('0x', '').padStart(64, '0');
            const token = CONFIG.TOKENS.WETH.toLowerCase().replace('0x', '').padStart(64, '0');
            const amount = opp.initialAmount.toString(16).padStart(64, '0');
            
            // This is a simplified encoding - actual implementation needs proper ABI encoding
            return selector + recipient + token + amount;
        }
        
        async function monitorTransaction(txHash, opp) {
            for (let i = 0; i < 120; i++) { // 4 minutes max
                await new Promise(r => setTimeout(r, 2000));
                
                try {
                    const receipt = await web3Provider.request({
                        method: 'eth_getTransactionReceipt',
                        params: [txHash]
                    });
                    
                    if (receipt) {
                        if (receipt.status === '0x1') {
                            log(``, 'success');
                            log(`üéâ ========== SUCCESS! ==========`, 'success');
                            log(`üí∞ PROFIT REALIZED: +${opp.netProfitPercent.toFixed(4)}%`, 'success');
                            log(`üíµ Amount: ${fromWei(opp.netProfit)} ETH`, 'success');
                            log(`üß† AI prediction: ${opp.aiPrediction.neuralScore}% ‚úÖ`, 'success');
                            log(`üîó View: ${CONFIG.EXPLORER}/tx/${txHash}`, 'success');
                            log(``, 'success');
                            
                            await updateBalance();
                            
                            // Play success sound (if browser allows)
                            try {
                                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+Dy');
                                audio.play();
                            } catch {}
                            
                        } else {
                            log(`‚ùå Transaction FAILED`, 'error');
                            log(`üí° Flash loan reverted - No funds lost!`, 'info');
                            log(`üîß This is normal - opportunity was front-run or expired`, 'info');
                        }
                        break;
                    }
                } catch (error) {
                    // Continue waiting
                }
                
                if (i % 5 === 0) {
                    log(`‚è≥ Still waiting... (${i * 2}s)`, 'info');
                }
            }
        }
        
        // ============================================================
        // SCANNER CONTROLS
        // ============================================================
        
        function startScanner() {
            if (!neuralNetwork.trained) {
                log('‚ö†Ô∏è Train neural network first!', 'warning');
                return;
            }
            
            if (!userAddress) {
                log('‚ö†Ô∏è Connect wallet first!', 'warning');
                return;
            }
            
            if (isScanning) {
                log('‚ö†Ô∏è Scanner already running', 'warning');
                return;
            }
            
            isScanning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            log('', 'success');
            log('üöÄ ========== SCANNER STARTED ==========', 'success');
            log('üîç Scanning Uniswap V3 pools on Base...', 'info');
            log(`‚ö° Target: ${CONFIG.PARALLEL_CHECKS} parallel checks`, 'info');
            log(`üéØ Min profit: ${CONFIG.MIN_PROFIT_PERCENT}%`, 'info');
            log(`üß† AI confidence threshold: 60%`, 'info');
            log('', 'success');
            
            totalChecks = 0;
            lastCheckTime = Date.now();
            
            scanForArbitrage();
            scanInterval = setInterval(scanForArbitrage, CONFIG.SCAN_INTERVAL);
        }
        
        function stopScanner() {
            isScanning = false;
            clearInterval(scanInterval);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            log('‚è∏Ô∏è Scanner stopped', 'warning');
            checksPerSecond = 0;
            document.getElementById('checksPerSecond').textContent = '0';
        }
        
        // ============================================================
        // INITIALIZATION
        // ============================================================
        
        function initialize() {
            log('‚ö° NEURAL FLASH ARBITRAGE PRO', 'success');
            log('üîÆ Balancer Flash Loans + Uniswap V3', 'info');
            log('üß† AI-Powered Arbitrage Detection', 'info');
            log('üíé Base Network - Ultra Low Gas', 'success');
            log('', 'info');
            log('üìã SETUP STEPS:', 'warning');
            log('1Ô∏è‚É£ Train the Neural Network (2 minutes)', 'info');
            log('2Ô∏è‚É£ Connect your OKX Wallet', 'info');
            log('3Ô∏è‚É£ Start the scanner', 'info');
            log('4Ô∏è‚É£ Approve transactions when AI finds opportunities', 'info');
            log('', 'info');
            log('‚úÖ System ready!', 'success');
            
            document.getElementById('trainBtn').addEventListener('click', trainNeuralNetwork);
            document.getElementById('connectBtn').addEventListener('click', connectWallet);
            document.getElementById('startBtn').addEventListener('click', startScanner);
            document.getElementById('stopBtn').addEventListener('click', stopScanner);
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
